use crate::camera::Camera;
use crate::fractal::{FractalParams, RenderMode};
use bytemuck::{Pod, Zeroable};
use glam::Mat4;
use wgpu::util::DeviceExt;

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
struct Uniforms {
    // Camera (3D mode)
    view_proj: [[f32; 4]; 4],
    inv_view_proj: [[f32; 4]; 4],
    camera_pos: [f32; 3],
    _padding1: f32,

    // 2D fractal parameters
    center: [f32; 2],
    zoom: f32,
    max_iterations: u32,

    // Julia set parameters
    julia_c: [f32; 2],
    fractal_type: u32, // 0: Mandelbrot, 1: Julia, 2: Mandelbulb, 3: Menger
    render_mode: u32,  // 0: 2D, 1: 3D

    // 3D fractal parameters
    power: f32,
    max_steps: u32,
    min_distance: f32,
    fractal_scale: f32,
    fractal_fold: f32,
    fractal_min_radius: f32,
    _padding2: [f32; 2], // Adjusted for alignment

    // Color palette
    palette: [[f32; 4]; 5], // 5 colors with padding

    // Rendering flags
    ambient_occlusion: u32,
    soft_shadows: u32,
    depth_of_field: u32,
    shading_model: u32, // 0: Blinn-Phong, 1: PBR
    color_mode: u32,    // Color visualization mode
    orbit_trap_scale: f32,
    palette_offset: f32,
    channel_r: u32,      // Red channel source
    channel_g: u32,      // Green channel source
    channel_b: u32,      // Blue channel source
    _padding_color: u32, // Padding for 16-byte alignment

    // Material properties
    roughness: f32,
    metallic: f32,
    _padding_vec3_align1: [f32; 3], // WGSL adds 12 bytes to align next vec3 to 16-byte boundary
    _padding_before_albedo: [f32; 3], // Actual vec3 field in WGSL
    _padding_vec3_align2: f32,      // WGSL adds 4 bytes to align next vec3 to 16-byte boundary
    albedo: [f32; 3],
    _padding3: f32,

    // DoF parameters
    dof_focal_length: f32,
    dof_aperture: f32,
    dof_samples: u32,
    time: f32,
    light_intensity: f32,
    ambient_light: f32,
    ao_intensity: f32,
    ao_step_size: f32,
    shadow_softness: f32,
    shadow_max_distance: f32,
    shadow_samples: u32,
    shadow_step_factor: f32,

    // Light direction
    light_azimuth: f32,       // Horizontal angle in degrees (0-360)
    light_elevation: f32,     // Vertical angle in degrees (5-90)
    _padding_light: [f32; 2], // Maintain 16-byte alignment

    // Floor
    show_floor: u32,
    floor_height: f32,
    _padding_floor: [f32; 2], // Padding for vec3 alignment
    floor_color1: [f32; 3],
    _padding_floor1: f32,
    floor_color2: [f32; 3],
    floor_reflections: u32,
    floor_reflection_strength: f32,
    _padding_floor3_align: [f32; 3], // Explicit padding to match WGSL implicit vec3 alignment to 16-byte boundary
    _padding_floor3: [f32; 3],

    // Ray marching
    use_adaptive_step: u32,
    fixed_step_size: f32,
    step_multiplier: f32,
    max_distance: f32,

    // Fog
    fog_enabled: u32,
    fog_mode: u32, // 0: Linear, 1: Exponential, 2: Quadratic
    fog_density: f32,
    _padding_fog: f32,            // Align to 8-byte boundary
    _padding_fog_vec3_align: f32, // Align fog_color to 16-byte boundary (WGSL requirement)
    fog_color: [f32; 3],
    _padding_fog_color: f32,

    // Post-processing
    brightness: f32,
    contrast: f32,
    saturation: f32,
    hue_shift: f32,
    vignette_enabled: u32,
    vignette_intensity: f32,
    vignette_radius: f32,
    bloom_enabled: u32,
    bloom_threshold: f32,
    bloom_intensity: f32,
    bloom_radius: f32,
    fxaa_enabled: u32,

    // High-precision center for deep zoom (double-float emulation)
    center_hi: [f32; 2],         // High part of center (x, y)
    center_lo: [f32; 2],         // Low part of center (x, y)
    high_precision: u32,         // Flag: 1 = use high precision
    _hp_padding_align: [f32; 3], // WGSL adds 12 bytes implicit padding before vec3 to align to 16-byte boundary
    _hp_padding: [f32; 4],       // vec3 in WGSL (16 bytes with padding)

    // LOD debug visualization
    lod_debug_enabled: u32, // Flag: 1 = show LOD zones as colors
    lod_zone1: f32,         // Distance threshold: Ultra -> High
    lod_zone2: f32,         // Distance threshold: High -> Medium
    lod_zone3: f32,         // Distance threshold: Medium -> Low

    // Padding for 16-byte alignment - reduced to account for new fields and vec3 alignment fix
    _padding_end: [f32; 28], // 112 bytes (reduced by 16 for LOD fields)
    _padding_end2: [f32; 8], // 32 bytes (reduced by 16 for vec3 alignment fixes)
}

impl Uniforms {
    fn new() -> Self {
        Self {
            view_proj: Mat4::IDENTITY.to_cols_array_2d(),
            inv_view_proj: Mat4::IDENTITY.to_cols_array_2d(),
            camera_pos: [0.0, 0.0, 3.0],
            _padding1: 0.0,
            center: [0.0, 0.0],
            zoom: 1.0,
            max_iterations: 80,
            julia_c: [-0.7, 0.27015],
            fractal_type: 0,
            render_mode: 0,
            power: 8.0,
            max_steps: 325,
            min_distance: 0.00035,
            fractal_scale: 2.0,
            fractal_fold: 1.0,
            fractal_min_radius: 0.5,
            _padding2: [0.0; 2],
            palette: [[0.0; 4]; 5],
            ambient_occlusion: 1,
            soft_shadows: 1,
            depth_of_field: 0,
            shading_model: 1, // PBR
            color_mode: 0,    // Palette
            orbit_trap_scale: 1.0,
            palette_offset: 0.0,
            channel_r: 0, // Iterations
            channel_g: 1, // Distance
            channel_b: 4, // PositionZ
            _padding_color: 0,
            roughness: 0.3,
            metallic: 0.15,
            _padding_vec3_align1: [0.0, 0.0, 0.0],
            _padding_before_albedo: [0.0, 0.0, 0.0],
            _padding_vec3_align2: 0.0,
            albedo: [0.8, 0.8, 0.8],
            _padding3: 0.0,
            dof_focal_length: 5.0,
            dof_aperture: 0.1,
            dof_samples: 2,
            time: 0.0,
            light_intensity: 4.5,
            ambient_light: 0.15,
            ao_intensity: 3.0,
            ao_step_size: 0.12,
            shadow_softness: 8.0,
            shadow_max_distance: 5.0,
            shadow_samples: 128,
            shadow_step_factor: 0.6,

            light_azimuth: 45.0,
            light_elevation: 60.0,
            _padding_light: [0.0; 2],

            show_floor: 1,
            floor_height: -2.0,
            _padding_floor: [0.0; 2],
            floor_color1: [1.0, 1.0, 1.0], // White
            _padding_floor1: 0.0,
            floor_color2: [0.0, 0.0, 0.0], // Black
            floor_reflections: 0,
            floor_reflection_strength: 0.7,
            _padding_floor3_align: [0.0; 3],
            _padding_floor3: [0.0; 3],

            use_adaptive_step: 1,
            fixed_step_size: 0.1,
            step_multiplier: 0.7,
            max_distance: 100.0,

            fog_enabled: 0,
            fog_mode: 1, // Exponential
            fog_density: 0.001,
            _padding_fog: 0.0,
            _padding_fog_vec3_align: 0.0,
            fog_color: [0.2, 0.2, 0.2], // Dark grey
            _padding_fog_color: 0.0,

            brightness: 1.0,
            contrast: 1.0,
            saturation: 1.0,
            hue_shift: 0.0,
            vignette_enabled: 0,
            vignette_intensity: 0.5,
            vignette_radius: 0.8,
            bloom_enabled: 0,
            bloom_threshold: 0.7,
            bloom_intensity: 0.5,
            bloom_radius: 0.005,
            fxaa_enabled: 0,

            center_hi: [0.0, 0.0],
            center_lo: [0.0, 0.0],
            high_precision: 0,
            _hp_padding_align: [0.0; 3],
            _hp_padding: [0.0; 4],

            lod_debug_enabled: 0,
            lod_zone1: 10.0, // Default LOD thresholds
            lod_zone2: 25.0,
            lod_zone3: 50.0,

            _padding_end: [0.0; 28],
            _padding_end2: [0.0; 8],
        }
    }

    fn update(&mut self, camera: &Camera, params: &FractalParams, time: f32) {
        let view_proj = camera.build_view_projection_matrix();
        self.view_proj = view_proj.to_cols_array_2d();
        self.inv_view_proj = view_proj.inverse().to_cols_array_2d();
        self.camera_pos = camera.position.into();

        self.center = [params.center_2d[0] as f32, params.center_2d[1] as f32];
        self.zoom = params.zoom_2d;

        // High-precision center: split f64 into (hi, lo) pair
        // Auto-enable high precision when zoom > 1e6
        let use_high_precision = params.zoom_2d > 1_000_000.0;
        self.high_precision = if use_high_precision { 1 } else { 0 };

        // Split center coordinates into double-float pairs
        // hi = value as f32, lo = (value - hi as f64) as f32
        let center_x = params.center_2d[0];
        let center_y = params.center_2d[1];
        self.center_hi = [center_x as f32, center_y as f32];
        self.center_lo = [
            (center_x - self.center_hi[0] as f64) as f32,
            (center_y - self.center_hi[1] as f64) as f32,
        ];

        // Auto-scale iterations with zoom for 2D fractals, combined with user slider
        if params.render_mode == crate::fractal::RenderMode::TwoD {
            let zoom_bonus = (params.zoom_2d.max(1.0).log2() * 15.0) as u32;
            self.max_iterations = params.max_iterations + zoom_bonus;
        } else {
            self.max_iterations = params.max_iterations;
        }
        self.julia_c = params.julia_c;

        self.fractal_type = match params.fractal_type {
            // 2D fractals (0-11)
            crate::fractal::FractalType::Mandelbrot2D => 0,
            crate::fractal::FractalType::Julia2D => 1,
            crate::fractal::FractalType::Sierpinski2D => 2,
            crate::fractal::FractalType::BurningShip2D => 3,
            crate::fractal::FractalType::Tricorn2D => 4,
            crate::fractal::FractalType::Phoenix2D => 5,
            crate::fractal::FractalType::Celtic2D => 6,
            crate::fractal::FractalType::Newton2D => 7,
            crate::fractal::FractalType::Lyapunov2D => 8,
            crate::fractal::FractalType::Nova2D => 9,
            crate::fractal::FractalType::Magnet2D => 10,
            crate::fractal::FractalType::Collatz2D => 11,
            // 3D fractals (12-20)
            crate::fractal::FractalType::Mandelbulb3D => 12,
            crate::fractal::FractalType::MengerSponge3D => 13,
            crate::fractal::FractalType::SierpinskiPyramid3D => 14,
            crate::fractal::FractalType::JuliaSet3D => 15,
            crate::fractal::FractalType::Mandelbox3D => 16,
            crate::fractal::FractalType::TgladFormula3D => 17,
            crate::fractal::FractalType::OctahedralIFS3D => 18,
            crate::fractal::FractalType::IcosahedralIFS3D => 19,
            crate::fractal::FractalType::ApollonianGasket3D => 20,
            crate::fractal::FractalType::Kleinian3D => 21,
            crate::fractal::FractalType::HybridMandelbulbJulia3D => 22,
            crate::fractal::FractalType::QuaternionCubic3D => 23,
        };

        self.render_mode = match params.render_mode {
            RenderMode::TwoD => 0,
            RenderMode::ThreeD => 1,
        };

        self.power = params.power;
        self.max_steps = params.max_steps;
        self.min_distance = params.min_distance;
        // Pass scale parameters directly - each fractal handles them appropriately
        self.fractal_scale = params.fractal_scale;
        self.fractal_fold = params.fractal_fold;
        self.fractal_min_radius = params.fractal_min_radius;

        // Update palette
        for (i, color) in params.palette.colors.iter().enumerate() {
            self.palette[i] = [color.x, color.y, color.z, 1.0];
        }

        self.ambient_occlusion = if params.ambient_occlusion { 1 } else { 0 };
        // shadow_mode: 0=off,1=hard,2=soft; pass through for shader
        self.soft_shadows = params.shadow_mode;
        self.depth_of_field = if params.depth_of_field { 1 } else { 0 };
        self.shading_model = match params.shading_model {
            crate::fractal::ShadingModel::BlinnPhong => 0,
            crate::fractal::ShadingModel::PBR => 1,
        };

        self.color_mode = match params.color_mode {
            crate::fractal::ColorMode::Palette => 0,
            crate::fractal::ColorMode::RaySteps => 1,
            crate::fractal::ColorMode::Normals => 2,
            crate::fractal::ColorMode::OrbitTrapXYZ => 3,
            crate::fractal::ColorMode::OrbitTrapRadial => 4,
            crate::fractal::ColorMode::WorldPosition => 5,
            crate::fractal::ColorMode::LocalPosition => 6,
            crate::fractal::ColorMode::AmbientOcclusion => 7,
            crate::fractal::ColorMode::PerChannel => 8,
            crate::fractal::ColorMode::DistanceField => 9,
            crate::fractal::ColorMode::Depth => 10,
            crate::fractal::ColorMode::Convergence => 11,
            crate::fractal::ColorMode::LightingOnly => 12,
            crate::fractal::ColorMode::ShadowMap => 13,
            crate::fractal::ColorMode::CameraDistanceLOD => 14,
            crate::fractal::ColorMode::DistanceGrayscale => 15,
        };

        self.orbit_trap_scale = params.orbit_trap_scale;
        self.palette_offset = params.palette_offset;

        // Convert channel sources to shader-compatible values
        self.channel_r = match params.channel_r {
            crate::fractal::ChannelSource::Iterations => 0,
            crate::fractal::ChannelSource::Distance => 1,
            crate::fractal::ChannelSource::PositionX => 2,
            crate::fractal::ChannelSource::PositionY => 3,
            crate::fractal::ChannelSource::PositionZ => 4,
            crate::fractal::ChannelSource::Normal => 5,
            crate::fractal::ChannelSource::AO => 6,
            crate::fractal::ChannelSource::Constant => 7,
        };
        self.channel_g = match params.channel_g {
            crate::fractal::ChannelSource::Iterations => 0,
            crate::fractal::ChannelSource::Distance => 1,
            crate::fractal::ChannelSource::PositionX => 2,
            crate::fractal::ChannelSource::PositionY => 3,
            crate::fractal::ChannelSource::PositionZ => 4,
            crate::fractal::ChannelSource::Normal => 5,
            crate::fractal::ChannelSource::AO => 6,
            crate::fractal::ChannelSource::Constant => 7,
        };
        self.channel_b = match params.channel_b {
            crate::fractal::ChannelSource::Iterations => 0,
            crate::fractal::ChannelSource::Distance => 1,
            crate::fractal::ChannelSource::PositionX => 2,
            crate::fractal::ChannelSource::PositionY => 3,
            crate::fractal::ChannelSource::PositionZ => 4,
            crate::fractal::ChannelSource::Normal => 5,
            crate::fractal::ChannelSource::AO => 6,
            crate::fractal::ChannelSource::Constant => 7,
        };

        self.roughness = params.roughness;
        self.metallic = params.metallic;
        self.albedo = params.albedo.into();

        self.dof_focal_length = params.dof_focal_length;
        self.dof_aperture = params.dof_aperture;
        self.dof_samples = params.dof_samples;
        self.time = time;
        self.light_intensity = params.light_intensity;
        self.ambient_light = params.ambient_light;
        self.ao_intensity = params.ao_intensity;
        self.ao_step_size = params.ao_step_size;
        self.shadow_softness = params.shadow_softness;
        self.shadow_max_distance = params.shadow_max_distance;
        self.shadow_samples = params.shadow_samples;
        self.shadow_step_factor = params.shadow_step_factor;

        self.light_azimuth = params.light_azimuth;
        self.light_elevation = params.light_elevation;

        self.show_floor = if params.show_floor { 1 } else { 0 };
        self.floor_height = params.floor_height;
        self.floor_color1 = params.floor_color1.into();
        self.floor_color2 = params.floor_color2.into();
        self.floor_reflections = if params.floor_reflections { 1 } else { 0 };
        self.floor_reflection_strength = params.floor_reflection_strength;

        self.use_adaptive_step = if params.use_adaptive_step { 1 } else { 0 };
        self.fixed_step_size = params.fixed_step_size;
        self.step_multiplier = params.step_multiplier;
        self.max_distance = params.max_distance;

        self.fog_enabled = if params.fog_enabled { 1 } else { 0 };
        self.fog_mode = match params.fog_mode {
            crate::fractal::FogMode::Linear => 0,
            crate::fractal::FogMode::Exponential => 1,
            crate::fractal::FogMode::Quadratic => 2,
        };
        self.fog_density = params.fog_density;
        self.fog_color = params.fog_color.into();

        // Post-processing
        self.brightness = params.brightness;
        self.contrast = params.contrast;
        self.saturation = params.saturation;
        self.hue_shift = params.hue_shift;
        self.vignette_enabled = if params.vignette_enabled { 1 } else { 0 };
        self.vignette_intensity = params.vignette_intensity;
        self.vignette_radius = params.vignette_radius;
        self.bloom_enabled = if params.bloom_enabled { 1 } else { 0 };
        self.bloom_threshold = params.bloom_threshold;
        self.bloom_intensity = params.bloom_intensity;
        self.bloom_radius = params.bloom_radius;
        self.fxaa_enabled = if params.fxaa_enabled { 1 } else { 0 };

        // LOD debug visualization
        let lod_enabled = params.lod_config.enabled && params.lod_config.debug_visualization;
        self.lod_debug_enabled = if lod_enabled { 1 } else { 0 };
        self.lod_zone1 = params.lod_config.distance_zones[0];
        self.lod_zone2 = params.lod_config.distance_zones[1];
        self.lod_zone3 = params.lod_config.distance_zones[2];
    }
}

// Compile-time assertion to ensure struct size matches WGSL expectations
const _: () = assert!(
    std::mem::size_of::<Uniforms>() == 832,
    "Uniforms struct must be exactly 832 bytes"
);

// Post-processing uniform structs
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
struct BloomUniforms {
    threshold: f32,
    intensity: f32,
    _padding: [f32; 2],
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
struct BlurUniforms {
    direction: [f32; 2], // (1,0) for horizontal, (0,1) for vertical
    _padding: [f32; 2],
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
struct PostProcessUniforms {
    brightness: f32, // offset 0
    contrast: f32,   // offset 4
    saturation: f32, // offset 8
    hue_shift: f32,  // offset 12

    vignette_enabled: u32,   // offset 16
    vignette_intensity: f32, // offset 20
    vignette_radius: f32,    // offset 24
    _padding1: f32,          // offset 28 (align to 16 bytes)

    bloom_enabled: u32,   // offset 32
    bloom_intensity: f32, // offset 36
    _padding2: [f32; 2],  // offset 40 (pad to 48)

    _padding3: [f32; 4], // offset 48 (vec3 + alignment = 16 bytes)
                         // Total: 64 bytes
}

/// Information about an available GPU adapter
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GpuInfo {
    pub index: usize,
    pub name: String,
    pub backend: String,
    pub device_type: String,
}

pub struct Renderer {
    pub surface: wgpu::Surface<'static>,
    pub device: wgpu::Device,
    pub queue: wgpu::Queue,
    pub config: wgpu::SurfaceConfiguration,
    pub size: winit::dpi::PhysicalSize<u32>,

    // Main fractal rendering
    pub render_pipeline: wgpu::RenderPipeline,
    pub vertex_buffer: wgpu::Buffer,
    pub uniform_buffer: wgpu::Buffer,
    pub uniform_bind_group: wgpu::BindGroup,
    uniforms: Uniforms,
    start_time: std::time::Instant,

    // Multi-pass post-processing
    pub scene_texture: wgpu::Texture,
    pub scene_view: wgpu::TextureView,
    pub bright_texture: wgpu::Texture,
    pub bright_view: wgpu::TextureView,
    pub blur_temp_texture: wgpu::Texture,
    pub blur_temp_view: wgpu::TextureView,
    pub bloom_texture: wgpu::Texture,
    pub bloom_view: wgpu::TextureView,
    pub composite_texture: wgpu::Texture,
    pub composite_view: wgpu::TextureView,

    pub sampler: wgpu::Sampler,
    pub postprocess_vertex_buffer: wgpu::Buffer,

    // Post-processing pipelines
    pub bloom_extract_pipeline: wgpu::RenderPipeline,
    pub blur_pipeline: wgpu::RenderPipeline,
    pub composite_pipeline: wgpu::RenderPipeline,
    pub fxaa_pipeline: wgpu::RenderPipeline,
    pub copy_pipeline: wgpu::RenderPipeline,

    // Post-processing uniforms
    pub bloom_uniform_buffer: wgpu::Buffer,
    pub blur_uniform_buffer: wgpu::Buffer,
    pub composite_uniform_buffer: wgpu::Buffer,

    // Bind groups
    pub scene_bind_group: wgpu::BindGroup,
    pub bright_bind_group: wgpu::BindGroup,
    pub blur_temp_bind_group: wgpu::BindGroup,
    pub composite_bind_group: wgpu::BindGroup,
    pub composite_final_bind_group: wgpu::BindGroup, // For final pass (FXAA or copy)
    pub bloom_params_bind_group: wgpu::BindGroup,
    pub blur_h_params_bind_group: wgpu::BindGroup,
    pub blur_v_params_bind_group: wgpu::BindGroup,
    pub composite_params_bind_group: wgpu::BindGroup,
}

impl Renderer {
    /// Enumerate all available GPU adapters
    pub async fn enumerate_gpus() -> Vec<GpuInfo> {
        let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
            backends: wgpu::Backends::all(),
            ..Default::default()
        });

        let adapters = instance.enumerate_adapters(wgpu::Backends::all());
        adapters
            .into_iter()
            .enumerate()
            .map(|(index, adapter)| {
                let info = adapter.get_info();
                GpuInfo {
                    index,
                    name: info.name,
                    backend: format!("{:?}", info.backend),
                    device_type: format!("{:?}", info.device_type),
                }
            })
            .collect()
    }

    pub async fn new(
        window: std::sync::Arc<winit::window::Window>,
        size: winit::dpi::PhysicalSize<u32>,
    ) -> Self {
        Self::new_with_gpu_preference(window, size, None).await
    }

    pub async fn new_with_gpu_preference(
        window: std::sync::Arc<winit::window::Window>,
        size: winit::dpi::PhysicalSize<u32>,
        preferred_gpu_index: Option<usize>,
    ) -> Self {
        let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
            backends: wgpu::Backends::all(),
            ..Default::default()
        });

        let surface = instance.create_surface(window).unwrap();

        // Select adapter based on preference or fallback to default
        let adapter = if let Some(gpu_index) = preferred_gpu_index {
            // Try to get the adapter at the specified index
            let adapters = instance.enumerate_adapters(wgpu::Backends::all());

            if gpu_index < adapters.len() {
                let selected = adapters.into_iter().nth(gpu_index).unwrap();
                let info = selected.get_info();
                println!(
                    "Using selected GPU #{}: {} ({:?}, {:?})",
                    gpu_index, info.name, info.backend, info.device_type
                );
                selected
            } else {
                println!(
                    "Preferred GPU index {} not found, falling back to default",
                    gpu_index
                );
                instance
                    .request_adapter(&wgpu::RequestAdapterOptions {
                        power_preference: wgpu::PowerPreference::HighPerformance,
                        compatible_surface: Some(&surface),
                        force_fallback_adapter: false,
                    })
                    .await
                    .unwrap()
            }
        } else {
            // Use default selection
            instance
                .request_adapter(&wgpu::RequestAdapterOptions {
                    power_preference: wgpu::PowerPreference::HighPerformance,
                    compatible_surface: Some(&surface),
                    force_fallback_adapter: false,
                })
                .await
                .unwrap()
        };

        let (device, queue) = adapter
            .request_device(
                &wgpu::DeviceDescriptor {
                    label: None,
                    required_features: wgpu::Features::empty(),
                    required_limits: wgpu::Limits::default(),
                },
                None,
            )
            .await
            .unwrap();

        let surface_caps = surface.get_capabilities(&adapter);
        let surface_format = surface_caps
            .formats
            .iter()
            .copied()
            .find(|f| f.is_srgb())
            .unwrap_or(surface_caps.formats[0]);

        let config = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::COPY_SRC,
            format: surface_format,
            width: size.width,
            height: size.height,
            present_mode: wgpu::PresentMode::Fifo,
            alpha_mode: surface_caps.alpha_modes[0],
            view_formats: vec![],
            desired_maximum_frame_latency: 2,
        };

        surface.configure(&device, &config);

        // Load shader
        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("shaders/fractal.wgsl").into()),
        });

        // Create uniform buffer
        let uniforms = Uniforms::new();
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Uniform Buffer"),
            contents: bytemuck::cast_slice(&[uniforms]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let uniform_bind_group_layout =
            device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                entries: &[wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: Some(
                            std::num::NonZeroU64::new(std::mem::size_of::<Uniforms>() as u64)
                                .unwrap(),
                        ),
                    },
                    count: None,
                }],
                label: Some("uniform_bind_group_layout"),
            });

        let uniform_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            layout: &uniform_bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
            label: Some("uniform_bind_group"),
        });

        let render_pipeline_layout =
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("Render Pipeline Layout"),
                bind_group_layouts: &[&uniform_bind_group_layout],
                push_constant_ranges: &[],
            });

        let render_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Render Pipeline"),
            layout: Some(&render_pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: "vs_main",
                buffers: &[wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<[f32; 2]>() as wgpu::BufferAddress,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &wgpu::vertex_attr_array![0 => Float32x2],
                }],
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: "fs_main",
                targets: &[Some(wgpu::ColorTargetState {
                    format: wgpu::TextureFormat::Rgba16Float, // Render to HDR intermediate texture
                    blend: Some(wgpu::BlendState::REPLACE),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleStrip,
                strip_index_format: None,
                front_face: wgpu::FrontFace::Ccw,
                cull_mode: None,
                polygon_mode: wgpu::PolygonMode::Fill,
                unclipped_depth: false,
                conservative: false,
            },
            depth_stencil: None,
            multisample: wgpu::MultisampleState {
                count: 1,
                mask: !0,
                alpha_to_coverage_enabled: false,
            },
            multiview: None,
        });

        // Fullscreen quad vertices
        let vertices: &[f32] = &[-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0];

        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Vertex Buffer"),
            contents: bytemuck::cast_slice(vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });

        // ============================================================================
        // Multi-pass Post-Processing Setup
        // ============================================================================

        // Load post-processing shader
        let postprocess_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Post-Process Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("shaders/postprocess.wgsl").into()),
        });

        // Create sampler for texture sampling
        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            label: Some("Post-Process Sampler"),
            address_mode_u: wgpu::AddressMode::ClampToEdge,
            address_mode_v: wgpu::AddressMode::ClampToEdge,
            address_mode_w: wgpu::AddressMode::ClampToEdge,
            mag_filter: wgpu::FilterMode::Linear,
            min_filter: wgpu::FilterMode::Linear,
            mipmap_filter: wgpu::FilterMode::Nearest,
            ..Default::default()
        });

        // Create intermediate render textures
        let (scene_texture, scene_view) =
            Self::create_render_texture(&device, size.width, size.height, "Scene Texture");
        let (bright_texture, bright_view) =
            Self::create_render_texture(&device, size.width, size.height, "Bright Texture");
        let (blur_temp_texture, blur_temp_view) =
            Self::create_render_texture(&device, size.width, size.height, "Blur Temp Texture");
        let (bloom_texture, bloom_view) =
            Self::create_render_texture(&device, size.width, size.height, "Bloom Texture");
        let (composite_texture, composite_view) =
            Self::create_render_texture(&device, size.width, size.height, "Composite Texture");

        // Create post-processing vertex buffer (fullscreen quad with tex coords)
        // Format: [x, y, u, v] for each vertex
        let postprocess_vertices: &[f32] = &[
            -1.0, -1.0, 0.0, 1.0, // Bottom-left
            1.0, -1.0, 1.0, 1.0, // Bottom-right
            -1.0, 1.0, 0.0, 0.0, // Top-left
            1.0, 1.0, 1.0, 0.0, // Top-right
        ];
        let postprocess_vertex_buffer =
            device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
                label: Some("Post-Process Vertex Buffer"),
                contents: bytemuck::cast_slice(postprocess_vertices),
                usage: wgpu::BufferUsages::VERTEX,
            });

        // Create post-processing uniform buffers
        let bloom_uniforms = BloomUniforms {
            threshold: 0.7,
            intensity: 0.5,
            _padding: [0.0; 2],
        };
        let bloom_uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Bloom Uniform Buffer"),
            contents: bytemuck::cast_slice(&[bloom_uniforms]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let blur_h_uniforms = BlurUniforms {
            direction: [1.0, 0.0], // Horizontal
            _padding: [0.0; 2],
        };
        let _blur_v_uniforms = BlurUniforms {
            direction: [0.0, 1.0], // Vertical
            _padding: [0.0; 2],
        };
        let blur_uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Blur Uniform Buffer"),
            contents: bytemuck::cast_slice(&[blur_h_uniforms]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let composite_uniforms = PostProcessUniforms {
            brightness: 1.0,
            contrast: 1.0,
            saturation: 1.0,
            hue_shift: 0.0,
            vignette_enabled: 0,
            vignette_intensity: 0.5,
            vignette_radius: 0.8,
            _padding1: 0.0,
            bloom_enabled: 0,
            bloom_intensity: 0.5,
            _padding2: [0.0; 2],
            _padding3: [0.0; 4],
        };
        let composite_uniform_buffer =
            device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
                label: Some("Composite Uniform Buffer"),
                contents: bytemuck::cast_slice(&[composite_uniforms]),
                usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
            });

        // Create bind group layouts
        // Layout for texture + sampler (group 0)
        let texture_bind_group_layout =
            device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                label: Some("Texture Bind Group Layout"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::FRAGMENT,
                        ty: wgpu::BindingType::Texture {
                            sample_type: wgpu::TextureSampleType::Float { filterable: true },
                            view_dimension: wgpu::TextureViewDimension::D2,
                            multisampled: false,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::FRAGMENT,
                        ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                        count: None,
                    },
                ],
            });

        // Layout for composite pass (scene + bloom textures)
        let composite_texture_layout =
            device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                label: Some("Composite Texture Layout"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::FRAGMENT,
                        ty: wgpu::BindingType::Texture {
                            sample_type: wgpu::TextureSampleType::Float { filterable: true },
                            view_dimension: wgpu::TextureViewDimension::D2,
                            multisampled: false,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::FRAGMENT,
                        ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::FRAGMENT,
                        ty: wgpu::BindingType::Texture {
                            sample_type: wgpu::TextureSampleType::Float { filterable: true },
                            view_dimension: wgpu::TextureViewDimension::D2,
                            multisampled: false,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::FRAGMENT,
                        ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                        count: None,
                    },
                ],
            });

        // Layout for uniforms (group 1)
        let uniform_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Post-Process Uniform Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });

        // Create post-processing render pipelines
        let vertex_buffer_layout = wgpu::VertexBufferLayout {
            array_stride: (std::mem::size_of::<f32>() * 4) as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &wgpu::vertex_attr_array![
                0 => Float32x2,  // position (x, y)
                1 => Float32x2,  // tex_coords (u, v)
            ],
        };

        // Bloom extract pipeline
        let bloom_extract_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Bloom Extract Layout"),
            bind_group_layouts: &[&texture_bind_group_layout, &uniform_layout],
            push_constant_ranges: &[],
        });

        let bloom_extract_pipeline =
            device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
                label: Some("Bloom Extract Pipeline"),
                layout: Some(&bloom_extract_layout),
                vertex: wgpu::VertexState {
                    module: &postprocess_shader,
                    entry_point: "vs_main",
                    buffers: std::slice::from_ref(&vertex_buffer_layout),
                },
                fragment: Some(wgpu::FragmentState {
                    module: &postprocess_shader,
                    entry_point: "fs_bloom_extract",
                    targets: &[Some(wgpu::ColorTargetState {
                        format: wgpu::TextureFormat::Rgba16Float,
                        blend: Some(wgpu::BlendState::REPLACE),
                        write_mask: wgpu::ColorWrites::ALL,
                    })],
                }),
                primitive: wgpu::PrimitiveState {
                    topology: wgpu::PrimitiveTopology::TriangleStrip,
                    ..Default::default()
                },
                depth_stencil: None,
                multisample: wgpu::MultisampleState::default(),
                multiview: None,
            });

        // Blur pipeline
        let blur_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Blur Layout"),
            bind_group_layouts: &[&texture_bind_group_layout, &uniform_layout],
            push_constant_ranges: &[],
        });

        let blur_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Blur Pipeline"),
            layout: Some(&blur_layout),
            vertex: wgpu::VertexState {
                module: &postprocess_shader,
                entry_point: "vs_main",
                buffers: std::slice::from_ref(&vertex_buffer_layout),
            },
            fragment: Some(wgpu::FragmentState {
                module: &postprocess_shader,
                entry_point: "fs_blur",
                targets: &[Some(wgpu::ColorTargetState {
                    format: wgpu::TextureFormat::Rgba16Float,
                    blend: Some(wgpu::BlendState::REPLACE),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleStrip,
                ..Default::default()
            },
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
        });

        // Composite pipeline
        let composite_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Composite Layout"),
            bind_group_layouts: &[&composite_texture_layout, &uniform_layout],
            push_constant_ranges: &[],
        });

        let composite_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Composite Pipeline"),
            layout: Some(&composite_layout),
            vertex: wgpu::VertexState {
                module: &postprocess_shader,
                entry_point: "vs_main",
                buffers: std::slice::from_ref(&vertex_buffer_layout),
            },
            fragment: Some(wgpu::FragmentState {
                module: &postprocess_shader,
                entry_point: "fs_composite",
                targets: &[Some(wgpu::ColorTargetState {
                    format: wgpu::TextureFormat::Rgba16Float,
                    blend: Some(wgpu::BlendState::REPLACE),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleStrip,
                ..Default::default()
            },
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
        });

        // FXAA pipeline
        let fxaa_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("FXAA Layout"),
            bind_group_layouts: &[&texture_bind_group_layout],
            push_constant_ranges: &[],
        });

        let fxaa_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("FXAA Pipeline"),
            layout: Some(&fxaa_layout),
            vertex: wgpu::VertexState {
                module: &postprocess_shader,
                entry_point: "vs_main",
                buffers: std::slice::from_ref(&vertex_buffer_layout),
            },
            fragment: Some(wgpu::FragmentState {
                module: &postprocess_shader,
                entry_point: "fs_fxaa",
                targets: &[Some(wgpu::ColorTargetState {
                    format: config.format,
                    blend: Some(wgpu::BlendState::REPLACE),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleStrip,
                ..Default::default()
            },
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
        });

        // Copy/passthrough pipeline (for when FXAA is disabled)
        let copy_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Copy Layout"),
            bind_group_layouts: &[&texture_bind_group_layout],
            push_constant_ranges: &[],
        });

        let copy_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Copy Pipeline"),
            layout: Some(&copy_layout),
            vertex: wgpu::VertexState {
                module: &postprocess_shader,
                entry_point: "vs_main",
                buffers: std::slice::from_ref(&vertex_buffer_layout),
            },
            fragment: Some(wgpu::FragmentState {
                module: &postprocess_shader,
                entry_point: "fs_copy",
                targets: &[Some(wgpu::ColorTargetState {
                    format: config.format,
                    blend: Some(wgpu::BlendState::REPLACE),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleStrip,
                ..Default::default()
            },
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
        });

        // Create bind groups for textures
        let scene_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Scene Bind Group"),
            layout: &texture_bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&scene_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&sampler),
                },
            ],
        });

        let bright_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Bright Bind Group"),
            layout: &texture_bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&bright_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&sampler),
                },
            ],
        });

        let blur_temp_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Blur Temp Bind Group"),
            layout: &texture_bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&blur_temp_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&sampler),
                },
            ],
        });

        let composite_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Composite Bind Group"),
            layout: &composite_texture_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&scene_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&sampler),
                },
                wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::TextureView(&bloom_view),
                },
                wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Sampler(&sampler),
                },
            ],
        });

        // Create bind groups for uniforms
        let bloom_params_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Bloom Params Bind Group"),
            layout: &uniform_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: bloom_uniform_buffer.as_entire_binding(),
            }],
        });

        let blur_h_params_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Blur H Params Bind Group"),
            layout: &uniform_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: blur_uniform_buffer.as_entire_binding(),
            }],
        });

        // For vertical blur, we'll need to update the buffer before use
        let blur_v_params_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Blur V Params Bind Group"),
            layout: &uniform_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: blur_uniform_buffer.as_entire_binding(),
            }],
        });

        let composite_params_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Composite Params Bind Group"),
            layout: &uniform_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: composite_uniform_buffer.as_entire_binding(),
            }],
        });

        // Final bind group for composite texture (for FXAA/copy to screen)
        let composite_final_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Composite Final Bind Group"),
            layout: &texture_bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&composite_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&sampler),
                },
            ],
        });

        Self {
            surface,
            device,
            queue,
            config,
            size,
            render_pipeline,
            vertex_buffer,
            uniform_buffer,
            uniform_bind_group,
            uniforms,
            start_time: std::time::Instant::now(),

            // Multi-pass post-processing
            scene_texture,
            scene_view,
            bright_texture,
            bright_view,
            blur_temp_texture,
            blur_temp_view,
            bloom_texture,
            bloom_view,
            composite_texture,
            composite_view,

            sampler,
            postprocess_vertex_buffer,

            bloom_extract_pipeline,
            blur_pipeline,
            composite_pipeline,
            fxaa_pipeline,
            copy_pipeline,

            bloom_uniform_buffer,
            blur_uniform_buffer,
            composite_uniform_buffer,

            scene_bind_group,
            bright_bind_group,
            blur_temp_bind_group,
            composite_bind_group,
            composite_final_bind_group,
            bloom_params_bind_group,
            blur_h_params_bind_group,
            blur_v_params_bind_group,
            composite_params_bind_group,
        }
    }

    // Helper: Create a render texture
    fn create_render_texture(
        device: &wgpu::Device,
        width: u32,
        height: u32,
        label: &str,
    ) -> (wgpu::Texture, wgpu::TextureView) {
        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some(label),
            size: wgpu::Extent3d {
                width,
                height,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba16Float,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
            view_formats: &[],
        });

        let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
        (texture, view)
    }

    // Helper: Recreate all intermediate textures (for resize)
    fn recreate_textures(&mut self) {
        let (scene_texture, scene_view) = Self::create_render_texture(
            &self.device,
            self.size.width,
            self.size.height,
            "Scene Texture",
        );
        self.scene_texture = scene_texture;
        self.scene_view = scene_view;

        let (bright_texture, bright_view) = Self::create_render_texture(
            &self.device,
            self.size.width,
            self.size.height,
            "Bright Texture",
        );
        self.bright_texture = bright_texture;
        self.bright_view = bright_view;

        let (blur_temp_texture, blur_temp_view) = Self::create_render_texture(
            &self.device,
            self.size.width,
            self.size.height,
            "Blur Temp Texture",
        );
        self.blur_temp_texture = blur_temp_texture;
        self.blur_temp_view = blur_temp_view;

        let (bloom_texture, bloom_view) = Self::create_render_texture(
            &self.device,
            self.size.width,
            self.size.height,
            "Bloom Texture",
        );
        self.bloom_texture = bloom_texture;
        self.bloom_view = bloom_view;

        let (composite_texture, composite_view) = Self::create_render_texture(
            &self.device,
            self.size.width,
            self.size.height,
            "Composite Texture",
        );
        self.composite_texture = composite_texture;
        self.composite_view = composite_view;

        // Recreate bind groups that use these textures
        // We need to get the bind group layouts from the pipelines
        let texture_bind_group_layout = self.bloom_extract_pipeline.get_bind_group_layout(0);
        let composite_texture_layout = self.composite_pipeline.get_bind_group_layout(0);

        self.scene_bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Scene Bind Group"),
            layout: &texture_bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&self.scene_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&self.sampler),
                },
            ],
        });

        self.bright_bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Bright Bind Group"),
            layout: &texture_bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&self.bright_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&self.sampler),
                },
            ],
        });

        self.blur_temp_bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Blur Temp Bind Group"),
            layout: &texture_bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&self.blur_temp_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&self.sampler),
                },
            ],
        });

        self.composite_bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Composite Bind Group"),
            layout: &composite_texture_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&self.scene_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&self.sampler),
                },
                wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::TextureView(&self.bloom_view),
                },
                wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Sampler(&self.sampler),
                },
            ],
        });

        self.composite_final_bind_group =
            self.device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Composite Final Bind Group"),
                layout: &texture_bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&self.composite_view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&self.sampler),
                    },
                ],
            });
    }

    pub fn resize(&mut self, new_size: winit::dpi::PhysicalSize<u32>) {
        if new_size.width > 0 && new_size.height > 0 {
            self.size = new_size;
            self.config.width = new_size.width;
            self.config.height = new_size.height;
            self.surface.configure(&self.device, &self.config);

            // Recreate intermediate textures for multi-pass rendering
            self.recreate_textures();
        }
    }

    pub fn update(&mut self, camera: &Camera, params: &FractalParams) {
        let time = self.start_time.elapsed().as_secs_f32();
        self.uniforms.update(camera, params, time);
        self.queue.write_buffer(
            &self.uniform_buffer,
            0,
            bytemuck::cast_slice(&[self.uniforms]),
        );

        // Update post-processing uniforms
        let bloom_uniforms = BloomUniforms {
            threshold: params.bloom_threshold,
            intensity: params.bloom_intensity,
            _padding: [0.0; 2],
        };
        self.queue.write_buffer(
            &self.bloom_uniform_buffer,
            0,
            bytemuck::cast_slice(&[bloom_uniforms]),
        );

        // Blur uniforms don't change (direction is fixed)
        // We use the same buffer for both H and V passes, just different bind groups

        let composite_uniforms = PostProcessUniforms {
            brightness: params.brightness,
            contrast: params.contrast,
            saturation: params.saturation,
            hue_shift: params.hue_shift,
            vignette_enabled: if params.vignette_enabled { 1 } else { 0 },
            vignette_intensity: params.vignette_intensity,
            vignette_radius: params.vignette_radius,
            _padding1: 0.0,
            bloom_enabled: if params.bloom_enabled { 1 } else { 0 },
            bloom_intensity: params.bloom_intensity,
            _padding2: [0.0; 2],
            _padding3: [0.0; 4],
        };
        self.queue.write_buffer(
            &self.composite_uniform_buffer,
            0,
            bytemuck::cast_slice(&[composite_uniforms]),
        );
    }
}
